# Руководство по Spring Cloud Gateway

## Введение: Роль API Gateway в микросервисной архитектуре

В современных распределенных системах, построенных на принципах микросервисов, возникает острая необходимость в единой точке входа, которая могла бы централизованно решать инфраструктурные задачи. **Spring Cloud Gateway (SCG)**, построенный на базе Spring Boot 2.x и Project Reactor (WebFlux), является реактивным, неблокирующим API-шлюзом, специально разработанным для этой цели.

SCG — это не просто прокси-сервер; это высокопроизводительный, настраиваемый **edge-слой**, который стоит на границе между внешними клиентами (веб-приложениями, мобильными устройствами, сторонними сервисами) и внутренними микросервисами.

---

## 1. Фундаментальная необходимость API Gateway

### 1.1. Проблемы, возникающие без централизованного Gateway

В архитектуре, где клиенты напрямую взаимодействуют с множеством бэкенд-сервисов, возникают следующие критические проблемы:

| Проблема                                       | Описание и последствия                                                                                                                                                                                                                           |
|:-----------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Дублирование инфраструктурной логики**       | Каждый бэкенд-сервис вынужден самостоятельно реализовывать общие функции: аутентификацию, авторизацию, логирование, Rate Limiting, CORS-заголовки. Это приводит к **дублированию кода**, увеличению времени разработки и повышению риска ошибок. |
| **Сложная эволюция API**                       | При изменении внутренней структуры сервисов (например, разделение одного сервиса на два) клиентам приходится менять логику маршрутизации. Gateway позволяет **абстрагировать** внутреннюю структуру от внешнего мира.                            |
| **Отсутствие единой точки контроля (SPOF)**    | Невозможно применить единую политику безопасности или мониторинга ко всей системе. Gateway предоставляет **единую точку входа** для применения сквозных политик.                                                                                 |
| **"Размазанная" маршрутизация и устойчивость** | Логика маршрутизации, таймаутов и повторных попыток (Retry) распределена по клиентским приложениям, что делает систему хрупкой и сложной в обслуживании.                                                                                         |

### 1.2. Роль и архитектурное позиционирование Gateway

Gateway выполняет роль **Edge-сервиса** (пограничного сервиса), беря на себя все инфраструктурные заботы:

*   **Маршрутизация (Routing):** Перенаправление запросов к соответствующим внутренним сервисам.
*   **Безопасность (Security):** Централизованная аутентификация (например, OAuth2/JWT-валидация) и авторизация.
*   **Устойчивость (Resilience):** Реализация паттернов Retry, Circuit Breaker и Fallback.
*   **Контроль трафика (Traffic Control):** Rate Limiting, IP-фильтрация, A/B-тестирование.
*   **Мониторинг и трассировка (Observability):** Единое место для сбора метрик и распределенной трассировки (Tracing).

> **Ключевой Принцип:** Gateway — это **часть инфраструктуры**, а не "ещё один микросервис". Он не должен содержать бизнес-логики.

---

## 2. Gateway как реактивный Pipeline (конвейер обработки)

Ключевая архитектурная модель SCG — это **реактивный pipeline** (конвейер), основанный на Project Reactor (`Mono` и `Flux`). Каждый входящий HTTP-запрос проходит через строго определенную цепочку обработки.

### 2.1. Этапы обработки запроса (Pipeline Flow)

1.  **Security/Pre-Processing:** Глобальные фильтры (Global Filters) обрабатывают запрос до маршрутизации (например, логирование, валидация токена).
2.  **Route Matching (Сопоставление Маршрута):** Запрос сопоставляется с набором определенных **Route** на основе **Predicates**.
3.  **Gateway Filters (Модификация):** Применяются фильтры, специфичные для выбранного маршрута, для модификации запроса (например, добавление заголовков, перезапись пути).
4.  **Backend Call (Вызов бэкенда):** Запрос отправляется к целевому URI внутреннего сервиса.
5.  **Post-Processing:** Глобальные и маршрутные фильтры обрабатывают ответ от бэкенда перед отправкой его клиенту (например, удаление заголовков, кэширование).

### 2.2. Следствие реактивной модели: явное управление потоком

Поскольку SCG использует реактивный подход, поток управляется **явно** через цепочки операторов (`.then()`, `.flatMap()`, `.filter()`).

> **Ключевое Следствие:** Если фильтр не вызывает следующий элемент в цепочке (`chain.filter(exchange)`), происходит **Short-circuit** (короткое замыкание), и дальнейшая обработка прекращается. Это позволяет эффективно управлять потоком и реализовывать политики деградации.

---

## 3. Route — декларативная модель маршрута

### 3.1. Определение Route

**Route** (Маршрут) — это основной строительный блок конфигурации SCG. Это **декларативное описание** того, как Gateway должен обрабатывать запросы.

Route состоит из трех ключевых элементов:

1.  **ID:** Уникальный идентификатор маршрута.
2.  **URI:** Целевой URI внутреннего сервиса (например, `lb://SERVICE-NAME` для балансировки нагрузки).
3.  **Predicates:** Набор условий, определяющих, подходит ли данный запрос этому маршруту.
4.  **Filters:** Набор действий, которые нужно выполнить с запросом или ответом.

### 3.2. Принцип декларативности

Route является **декларативным**, а не императивным, что означает:

*   **Предсказуемость:** Поведение Gateway легко анализируется и предсказуемо.
*   **Анализируемость:** Конфигурация может быть проанализирована инструментами мониторинга и аудита.
*   **Отсутствие бизнес-логики:** Route не содержит условий `if` или сложной бизнес-логики. Он просто описывает "что" и "куда".

---

## 4. Predicate — механизм выбора маршрута

**Predicate** (Предикат) — это функция, которая принимает объект `ServerWebExchange` и возвращает булево значение (`true` или `false`).

### 4.1. Роль Predicate

Единственная задача Predicate — ответить на вопрос: **"Подходит ли этот запрос данному Route?"**

*   **Не изменяет запрос:** Predicate не имеет побочных эффектов и не модифицирует запрос.
*   **Только выбор:** Используется исключительно для сопоставления.

Если ни один Predicate в Route не совпал, этот Route игнорируется, и Gateway переходит к следующему. Если ни один Route не совпал, возвращается ошибка **404 Not Found**.

### 4.2. Примеры встроенных Predicates

| Predicate | Описание | Пример Конфигурации (YAML) |
| :--- | :--- | :--- |
| `Path` | Сопоставление по шаблону пути URI. | `Path=/api/v1/**` |
| `Method` | Сопоставление по HTTP-методу. | `Method=GET,POST` |
| `Host` | Сопоставление по заголовку `Host`. | `Host=**.example.com` |
| `Header` | Сопоставление по наличию и значению заголовка. | `Header=X-Version,v1` |
| `Query` | Сопоставление по наличию и значению параметра запроса. | `Query=version,1.0` |
| `After/Before/Between` | Сопоставление по времени (для A/B-тестирования или временных акций). | `After=2025-01-01T00:00:00+03:00` |

---

## 5. GatewayFilter — Управляемая модификация запроса/ответа

**GatewayFilter** — это компонент, который позволяет модифицировать входящий запрос или исходящий ответ.

### 5.1. Применение и контекст

*   **Применяется после выбора маршрута:** Фильтр применяется только к тем запросам, которые успешно прошли сопоставление с Predicates данного Route.
*   **Часть Pipeline:** Фильтр может выполнять логику до вызова бэкенда (pre-filter) и после получения ответа (post-filter).

### 5.2. Типичные задачи GatewayFilter

*   **Модификация заголовков:** Добавление, удаление или изменение HTTP-заголовков (`AddRequestHeader`, `RemoveResponseHeader`).
*   **Перезапись пути (Path Rewriting):** Изменение пути URI перед отправкой на бэкенд (например, удаление префикса `/api/v1` перед отправкой на внутренний сервис).
*   **Управление устойчивостью:** Настройка специфичных для маршрута политик Retry и Circuit Breaker.
*   **Rate Limiting:** Применение ограничений на количество запросов для данного маршрута.

---

## 6. GlobalFilter — инфраструктурный слой

**GlobalFilter** (Глобальный фильтр) — это особый тип фильтра, который применяется **ко всем** маршрутам в Gateway.

### 6.1. Роль GlobalFilter

GlobalFilter реализует **сквозные инфраструктурные политики**, которые должны быть применены независимо от того, какой конечный сервис будет вызван.

*   **Не зависит от маршрута:** Он не знает, какой именно сервис будет вызван, и работает на уровне всего Gateway.
*   **Порядок выполнения:** Global Filters выполняются в соответствии с их `Order` (см. раздел 9).

### 6.2. Примеры GlobalFilter

*   **Логирование и мониторинг:** Запись информации о каждом входящем запросе и исходящем ответе.
*   **Трассировка (Tracing):** Добавление заголовков для распределенной трассировки (например, `X-B3-TraceId`).
*   **IP-Фильтрация:** Блокировка запросов с определенных IP-адресов.
*   **CORS-Обработка:** Добавление необходимых заголовков для Cross-Origin Resource Sharing.

---

## 7. ServerWebExchange — контекст запроса

**ServerWebExchange** — это центральный объект в реактивном pipeline SCG. Он инкапсулирует весь контекст текущего HTTP-запроса и ответа.

### 7.1. Содержимое ServerWebExchange

ServerWebExchange содержит:

*   **Request:** Объект `ServerHttpRequest` (входящий запрос).
*   **Response:** Объект `ServerHttpResponse` (исходящий ответ).
*   **Attributes:** Карта (`Map<String, Object>`) для передачи данных между различными фильтрами в рамках одного запроса.

### 7.2. Использование Attributes

Attributes — это **контейнер состояния** для pipeline. Например, Predicate может сохранить результат аутентификации в Attributes, а последующий GatewayFilter может использовать этот результат для добавления пользовательского ID в заголовок запроса к бэкенду.

> **Важно:** Attributes живут только в рамках одного запроса и не предназначены для хранения конфигурации или долгосрочного состояния.

---

## 8. Short-circuit — управляемая остановка Pipeline

**Short-circuit** (Короткое замыкание) — это механизм **осознанного и контролируемого завершения** обработки запроса до того, как он достигнет бэкенда.

### 8.1. Принцип Short-circuit

В реактивном pipeline фильтр может остановить дальнейшую обработку, вернув `Mono<Void>` без вызова `chain.filter(exchange)`.

### 8.2. Сценарии применения

Short-circuit используется, когда:

*   **Нарушена политика безопасности:** Токен недействителен, и необходимо немедленно вернуть **401 Unauthorized**.
*   **Rate Limit превышен:** Запрос превысил лимит, и нужно вернуть **429 Too Many Requests**.
*   **Недопустимая валидация:** Запрос не прошел базовую валидацию (например, отсутствует критический заголовок).

> **Отличие от Ошибки:** Short-circuit — это не ошибка (`Exception`), а **часть дизайна** и нормального потока управления.

---

## 9. Order фильтров — управление последовательностью

Порядок выполнения фильтров (`Order`) имеет критическое значение, поскольку он определяет, **кто увидит запрос первым** и **кто может его остановить**.

### 9.1. Правило Order

*   **Меньшее значение `Order` = Раньше Выполнение.**
*   Фильтры с более низким `Order` выполняются первыми и имеют приоритет в принятии решений (например, Short-circuit).

### 9.2. Архитектурное значение

Правильный порядок гарантирует, что:

1.  **Безопасность (Security)** всегда выполняется первой (самый низкий `Order`).
2.  **Логирование/Трассировка** выполняются до и после всех остальных действий.
3.  **Rate Limiting** выполняется до вызова бэкенда.

> **Order — это часть логики, а не косметическая настройка.** Неправильный порядок может привести к тому, что неавторизованный запрос достигнет бэкенда.

---

## 10. Retry — стратегия устойчивости

**Retry** (Повторная попытка) — это инфраструктурный механизм, позволяющий Gateway автоматически повторить вызов бэкенда в случае временной ошибки.

### 10.1. Принципы безопасного Retry

Retry должен применяться с осторожностью и только при соблюдении следующих условий:

*   **Только временные ошибки:** Применяется только к ошибкам, которые могут быть устранены при повторной попытке (например, **503 Service Unavailable**, таймаут).
*   **Идемпотентные операции:** Повторные попытки допустимы только для **идемпотентных** HTTP-методов (GET, PUT, DELETE, HEAD, OPTIONS). Повтор запроса POST может привести к дублированию транзакции.
*   **Ограниченное применение:** Retry применяется только к **backend-вызову**, а не к логике самого Gateway.

SCG использует библиотеку **Resilience4j** для реализации политики Retry.

---

## 11. Fallback и Circuit Breaker

Эти два паттерна являются ключевыми для реализации **деградации сервиса** и защиты от каскадных отказов.

### 11.1. Circuit Breaker (автоматический выключатель)

**Circuit Breaker** (предохранитель) защищает систему от **каскадных отказов**. Если бэкенд-сервис начинает отвечать ошибками с высокой частотой, Circuit Breaker переводит систему в одно из трех состояний:

1.  **Closed (Закрыт):** Нормальная работа.
2.  **Open (Открыт):** Все запросы немедленно отклоняются, возвращается Fallback-ответ.
3.  **Half-Open (Полуоткрыт):** Периодически пропускается один тестовый запрос, чтобы проверить, восстановился ли бэкенд.

### 11.2. Fallback (резервный ответ)

**Fallback** — это альтернативный ответ, который возвращается клиенту, когда:

*   Circuit Breaker находится в состоянии **Open**.
*   Произошла ошибка, которую не удалось исправить с помощью Retry.

Fallback выполняется **на стороне Gateway** и может быть простым статическим ответом или вызовом резервного сервиса.

---

## 12. Разделение ответственности: Backend vs. Gateway

Четкое разделение ответственности — основа правильной архитектуры.

| Ответственность     | Backend-Сервис | API Gateway |
|:--------------------| :--- | :--- |
| **Бизнес-логика**   | Полностью отвечает | Не должен содержать |
| **Бизнес-ошибки**   | Определяет смысл, статус и тело ответа (например, 400, 409) | **Не интерпретирует** |
| **Доставка ошибок** | Возвращает ошибку | Доставляет ошибку клиенту, может логировать |
| **Устойчивость**    | Не должен знать о Retry/Fallback | Реализует Retry, Circuit Breaker, Fallback |
| **Безопасность**    | Финальная проверка авторизации | Централизованная аутентификация (JWT/OAuth2) |

---

## 13. Валидация в Gateway

Gateway должен выполнять только ту валидацию, которая не требует знания **бизнес-смысла** запроса.

### 13.1. Допустимая (инфраструктурная) валидация

*   **Заголовки:** Проверка наличия и формата критических заголовков (например, `Authorization`, `Accept`).
*   **IP-Адреса:** Фильтрация по IP-адресам.
*   **Формат запроса:** Базовая проверка синтаксиса JSON/XML.
*   **Версия API:** Проверка, соответствует ли запрошенная версия API поддерживаемой.

### 13.2. Недопустимая (бизнес) валидация

*   **Валидация DTO (Data Transfer Object):** Проверка полей объекта (например, что поле `email` имеет правильный формат).
*   **Бизнес-правила:** Проверка, что пользователь имеет достаточно средств на счету или что товар есть в наличии.

> **Причина:** Gateway знает **форму** запроса (заголовки, путь), но не его **смысл**. Валидация DTO и бизнес-правил должна оставаться на **бэкенде**.

---

## 14. IP и Edge-политики

Gateway — идеальное место для применения политик, основанных на сетевых характеристиках.

### 14.1. Edge-политики

*   **Rate Limiting:** Ограничение частоты запросов от одного клиента (например, 100 запросов в минуту). SCG имеет встроенный фильтр `RateLimiter`.
*   **IP Allow/Deny:** Блокировка или разрешение доступа по списку IP-адресов.
*   **Geo Policies:** Маршрутизация или блокировка на основе географического положения клиента.

### 14.2. Определение IP-адреса клиента

При работе за прокси-серверами или балансировщиками (что типично для Gateway) необходимо правильно определить реальный IP-адрес клиента, используя следующие заголовки (в порядке приоритета):

1.  `X-Forwarded-For`
2.  `X-Real-IP`
3.  `RemoteAddress` (IP-адрес, с которого пришел запрос на Gateway)

---

## 15. Конфигурация: YAML vs. Java DSL

Spring Cloud Gateway предлагает два основных способа конфигурации маршрутов.

### 15.1. YAML (декларативный подход)

| Характеристика | Описание |
| :--- | :--- |
| **Подход** | Декларативный, статический. |
| **Применение** | Простые, фиксированные маршруты, где Predicates и Filters не требуют сложной логики. |
| **Преимущества** | Легкость чтения, простота конфигурации, не требует перекомпиляции. |
| **Недостатки** | Невозможность реализации сложной, динамической логики (например, условная маршрутизация). |

### 15.2. Java DSL (программируемый подход)

| Характеристика | Описание |
| :--- | :--- |
| **Подход** | Императивный, динамический. |
| **Применение** | Сложная логика маршрутизации, динамическое изменение маршрутов, условные Predicates или Filters. |
| **Преимущества** | Полный контроль над процессом, возможность использования любой Java-логики. |
| **Недостатки** | Требует перекомпиляции, сложнее для аудита. |

> **Формула Выбора:** Если вам нужен оператор `if` для принятия решения о маршрутизации или фильтрации, вам необходим **Java DSL**.

---

## 16. WebFlux Gateway — архитектурная платформа

**Spring Cloud Gateway** по умолчанию построен на стеке **Spring WebFlux**.

### 16.1. Ключевые архитектурные особенности

*   **Неблокирующий (Non-Blocking):** Использует неблокирующий ввод/вывод (NIO).
*   **Event-Loop архитектура:** Основан на реактивных потоках (Project Reactor), что позволяет обрабатывать огромное количество одновременных соединений с минимальным количеством потоков.
*   **Высокая пропускная Способность:** Идеально подходит для сценариев с высокой нагрузкой (high-load) и потоковой передачей данных (streaming).
*   **Полный Pipeline:** Поддерживает все возможности SCG, включая Java DSL.

### 16.2. Сценарии применения

WebFlux Gateway — это стандартный выбор для:

*   Основного **Entry Point** в микросервисной архитектуре.
*   Систем, требующих **высокой производительности** и эффективного использования ресурсов.
*   Реализации сложных **Edge-компонентов**.

---

## 17. MVC Gateway — компромиссный вариант

Spring Cloud Gateway также может быть настроен на работу с традиционным стеком **Spring Web MVC** (Servlet-based).

### 17.1. Ограничения MVC Gateway

*   **Блокирующий (Blocking):** Использует традиционную модель "один поток на запрос".
*   **Ограниченная производительность:** Менее эффективен при высокой конкурентной нагрузке.
*   **Отсутствие Java DSL:** Поддерживает только декларативную конфигурацию (YAML/Properties).

### 17.2. Сценарии применения

MVC Gateway — это **сознательно ограниченный** вариант, который может быть полезен для:

*   **Legacy-систем:** Интеграция с существующим стеком, основанным на Servlet.
*   **Миграционных сценариев:** Постепенный переход от монолита к микросервисам.
*   **Простого Routing:** Если требования к производительности минимальны, а нужна только базовая маршрутизация.

---

## 18. Рекомендации по выбору Gateway

Выбор между WebFlux и MVC Gateway должен быть основан на архитектурных требованиях:

| Критерий | WebFlux Gateway (рекомендуется)               | MVC Gateway (компромисс)                 |
| :--- |:----------------------------------------------|:-----------------------------------------|
| **Нагрузка** | Высокая, требуется масштабируемость.          | Низкая или умеренная.                    |
| **Архитектура** | Реактивная, неблокирующая.                    | Традиционная, блокирующая (Servlet).     |
| **Конфигурация** | Полная поддержка YAML и Java DSL.             | Только декларативная (YAML/Properties).  |
| **Роль** | Основной, высокопроизводительный Entry Point. | Временный, для Legacy или простых задач. |

> **Общее Правило:** Если Gateway является основным Entry Point вашей системы, **всегда выбирайте WebFlux Gateway** для обеспечения максимальной производительности и устойчивости.

---

## 19. Архитектурные анти-паттерны

Нарушение принципов разделения ответственности приводит к созданию "толстого" Gateway, который становится новым монолитом.

### 19.1. Список анти-паттернов

1.  **Бизнес-логика в Gateway:** Нельзя реализовывать логику, которая должна быть в бэкенде (например, сложные проверки данных, агрегация данных из нескольких сервисов).
2.  **DTO-валидация:** Нельзя проверять поля DTO, так как это требует знания бизнес-контракта.
3.  **Интерпретация бизнес-ошибок Backend:** Gateway не должен менять статус-коды или тело ответа бэкенда на основе бизнес-смысла ошибки.
4.  **Смешение Security и Gateway:** Хотя Gateway выполняет аутентификацию, сложная логика авторизации (ACL, RBAC) должна быть реализована в специализированном сервисе (например, Auth Service), а Gateway лишь вызывает его или валидирует токен.
